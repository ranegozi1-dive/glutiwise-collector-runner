name: Bootstrap stores automatically (Hod Hasharon area)

on:
  workflow_dispatch:

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - name: Prepare folders
        run: |
          mkdir -p dumps

      - name: Pull scraper image
        run: |
          docker pull erlichsefi/israeli-supermarket-scarpers:latest

      - name: Download STORE files (RAMI_LEVY + SHUFERSAL)
        run: |
          docker run --rm \
            -v "${{ github.workspace }}/dumps:/usr/src/app/dumps" \
            -e ENABLED_SCRAPERS="RAMI_LEVY,SHUFERSAL" \
            -e ENABLED_FILE_TYPES="STORE_FILE" \
            -e LIMIT=10 \
            erlichsefi/israeli-supermarket-scarpers:latest

      - name: Build payload (up to 30 stores near Hod Hasharon) and POST to Make
        env:
          MAKE_WEBHOOK_URL: ${{ secrets.MAKE_WEBHOOK_URL }}
          MAKE_APIKEY: ${{ secrets.MAKE_APIKEY }}
        run: |
          python3 - << 'PY' | curl -sS -X POST "$MAKE_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -H "x-make-apikey: $MAKE_APIKEY" \
              --data-binary @-
          import os, json, glob, re
          import xml.etree.ElementTree as ET
          from datetime import datetime, timezone

          # סינון לפי טקסט (City לעיתים מספרי), כדי להתמקד בהוד השרון והסביבה
          TARGET_TOKENS = [
              "הוד השרון", "כפר סבא", "רעננה", "הרצליה",
              "רמת השרון", "פתח תקווה", "תל אביב",
              "אחוזה", "רמת החייל"
          ]

          # מיפוי ChainID -> retailer (מבוסס על מה שראית בקבצים)
          CHAINID_TO_RETAILER = {
              "7290027600007": "ramilevy",
              "7290058140886": "shufersal",
          }

          def norm(s: str) -> str:
              return re.sub(r"\s+", " ", (s or "").strip())

          def text_any(elem, tags):
              for t in tags:
                  x = elem.find(t)
                  if x is not None and x.text:
                      return norm(x.text)
              return ""

          def get_chain_id(root):
              for tag in ("ChainID", "CHAINID"):
                  x = root.find(f".//{tag}")
                  if x is not None and x.text:
                      return norm(x.text)
              return ""

          def parse_store_file(path):
              root = ET.parse(path).getroot()
              chain_id = get_chain_id(root)
              stores = []
              for store in root.findall(".//Store"):
                  store_id = text_any(store, ["StoreID", "STOREID"])
                  city = text_any(store, ["City", "CITY"])
                  address = text_any(store, ["Address", "ADDRESS"])
                  name = text_any(store, ["StoreName", "STORENAME"])
                  if store_id:
                      stores.append((store_id, city, address, name))
              return chain_id, stores

          def looks_numeric(s: str) -> bool:
              return bool(re.fullmatch(r"\d{3,6}", s or ""))

          def add_store(selected, seen_keys, retailer, store_id, city, address, name):
              store_key = f"{retailer}:{store_id}"
              if store_key in seen_keys:
                  return
              seen_keys.add(store_key)
              selected.append({
                  "retailer": retailer,
                  "store_id": store_id,
                  "store_key": store_key,
                  "store_name": name or "",
                  "city": city or "",
                  "address": address or "",
                  "area": "",
                  "store_type": ""
              })

          # 1) קוראים את כל קבצי ה-Stores מה-dumps ומזהים רשת לפי ChainID (לא לפי שם קובץ)
          candidates = []
          for path in glob.glob("dumps/**/*.xml", recursive=True):
              base = os.path.basename(path).lower()
              if not base.startswith("stores"):
                  continue
              chain_id, stores = parse_store_file(path)
              retailer = CHAINID_TO_RETAILER.get(chain_id)
              if not retailer:
                  continue
              candidates.append((retailer, stores))

          if not candidates:
              raise SystemExit("לא נמצאו קבצי Stores תואמים ב-dumps או שה-ChainID לא ממופה.")

          selected = []
          seen_keys = set()

          # 2) עדיפות: טוקנים ב-StoreName/Address/City (אם City לא מספרי)
          for retailer, stores in candidates:
              for store_id, city, address, name in stores:
                  city_for_search = "" if looks_numeric(city) else city
                  hay = norm(f"{city_for_search} {address} {name}")
                  if any(tok in hay for tok in TARGET_TOKENS):
                      add_store(selected, seen_keys, retailer, store_id, city, address, name)
                  if len(selected) >= 30:
                      break
              if len(selected) >= 30:
                  break

          # 3) fallback יציב: אם לא הגיע ל-30, משלימים לפי סדר הופעה
          if len(selected) < 30:
              for retailer, stores in candidates:
                  for store_id, city, address, name in stores:
                      add_store(selected, seen_keys, retailer, store_id, city, address, name)
                      if len(selected) >= 30:
                          break
                  if len(selected) >= 30:
                      break

          now = datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")

          # מינימום records כדי להיכנס ל-Route A (stores+records) ב-Make
          payload = {
              "source": "bootstrap_stores_auto",
              "generated_at": now,
              "stores": selected[:30],
              "records": [{
                  "price_key": "7290000000011:ramilevy:001",
                  "barcode": "7290000000011",
                  "store_key": "ramilevy:001",
                  "price": 9.9,
                  "updated_at": now
              }]
          }

          print(json.dumps(payload, ensure_ascii=False))
          PY
