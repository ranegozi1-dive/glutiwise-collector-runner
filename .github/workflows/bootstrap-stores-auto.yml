name: GlutiWise Collector (ONE FLOW)

on:
  workflow_dispatch:
    inputs:
      run_mode:
        description: "inspect | stores | seed_products | stores_prices"
        required: true
        default: "inspect"
      send_to_make:
        description: "רק עבור stores / stores_prices: לשלוח POST ל-Make (true/false)"
        required: true
        default: "false"
      seed_limit:
        description: "כמה ברקודים להוציא ל-products_seed.csv (מומלץ 2000)"
        required: true
        default: "2000"

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Prepare folders
        run: |
          mkdir -p dumps out

      - name: Pull scraper image
        run: |
          docker pull erlichsefi/israeli-supermarket-scarpers:latest

      # =========================
      # INSPECT (no Make)
      # =========================
      - name: Inspect image (fast)
        if: ${{ inputs.run_mode == 'inspect' }}
        run: |
          set -e
          docker run --rm --entrypoint sh erlichsefi/israeli-supermarket-scarpers:latest -lc '
            set -e
            echo "== FIND file_types candidates =="
            find . -maxdepth 10 -type f -iname "*file_types*.py" | head -n 80 || true
            echo
            echo "== GREP hints =="
            grep -RIn --line-number --binary-files=without-match -E "ENABLED_FILE_TYPES|STORE_FILE|PRICE|PROMO|FULL|FILE_TYPE" . 2>/dev/null | head -n 200 || true
            echo "== DONE =="
          '

      # =========================
      # DISCOVER PRICE TYPES (no heredoc, no import assumptions)
      # =========================
      - name: Discover ENABLED_FILE_TYPES (SAFE - short -c, never empty)
        if: ${{ inputs.run_mode != 'inspect' }}
        id: discover
        run: |
          set -euo pipefail

          ENABLED_TYPES="$(docker run --rm --entrypoint python3 erlichsefi/israeli-supermarket-scarpers:latest -c 'from il_supermarket_scarper import FileTypesFilters; print(",".join(FileTypesFilters.all_types()))')"
          ENABLED_TYPES="$(echo "$ENABLED_TYPES" | tr -d "\r\n" | sed 's/,,*/,/g; s/^,//; s/,$//')"

          echo "Discovered ENABLED_FILE_TYPES: $ENABLED_TYPES"
          if [ -z "$ENABLED_TYPES" ]; then
            echo "ERROR:EMPTY_ENABLED_FILE_TYPES"
            exit 2
          fi

          echo "enabled_types=$ENABLED_TYPES" >> "$GITHUB_OUTPUT"

      # =========================
      # DOWNLOADS
      # =========================
      - name: Download STORE files (stores mode)
        if: ${{ inputs.run_mode == 'stores' }}
        run: |
          set -euo pipefail
          docker run --rm \
            -v "${{ github.workspace }}/dumps:/usr/src/app/dumps" \
            -e ENABLED_SCRAPERS="RAMI_LEVY,SHUFERSAL,YOHANANOF" \
            -e ENABLED_FILE_TYPES="STORE_FILE" \
            -e LIMIT=500 \
            erlichsefi/israeli-supermarket-scarpers:latest

      - name: Download STORE + PRICE files (seed_products / stores_prices)
        if: ${{ inputs.run_mode == 'seed_products' || inputs.run_mode == 'stores_prices' }}
        run: |
          set -euo pipefail

          TYPES="${{ steps.discover.outputs.enabled_types }}"
          echo "Discovered types: $TYPES"

          if echo "$TYPES" | grep -q "STORE_FILE"; then
            ENABLED_FILE_TYPES="$TYPES"
          else
            ENABLED_FILE_TYPES="STORE_FILE,$TYPES"
          fi

          # Safety: no empty tokens
          echo "$ENABLED_FILE_TYPES" | grep -q ",," && echo "ERROR:ENABLED_FILE_TYPES_HAS_EMPTY_TOKEN" && exit 2

          docker run --rm \
            -v "${{ github.workspace }}/dumps:/usr/src/app/dumps" \
            -e ENABLED_SCRAPERS="RAMI_LEVY,SHUFERSAL,YOHANANOF" \
            -e ENABLED_FILE_TYPES="$ENABLED_FILE_TYPES" \
            -e LIMIT=120 \
            erlichsefi/israeli-supermarket-scarpers:latest

      # =========================
      # BUILD (stores mode): out/payload.json
      # =========================
      - name: Build payload (stores + dummy record) -> out/payload.json
        if: ${{ inputs.run_mode == 'stores' }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os, json, glob, re
          import xml.etree.ElementTree as ET
          from datetime import datetime, timezone

          TARGET_TOKENS = ["הוד השרון","כפר סבא","רעננה","הרצליה","רמת השרון","פתח תקווה","תל אביב","אחוזה"]
          CHAINID_TO_RETAILER = {"7290027600007":"ramilevy","7290058140886":"shufersal"}

          LIMIT_RAMI_SHUF_TOTAL = 30
          PER_RETAILER_YOH = 15

          DUMMY_BARCODE = "7290000000011"
          DUMMY_PRICE = 9.9

          def now_z():
              return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00","Z")

          def norm(s): return re.sub(r"\s+"," ",(s or "").strip())
          def localname(tag): return tag.split("}")[-1] if "}" in tag else tag
          def looks_numeric(s): return bool(re.fullmatch(r"\d{1,12}", (s or "").strip()))

          def find_first(root, wanted):
              wl=wanted.lower()
              for el in root.iter():
                  if localname(el.tag).lower()==wl and (el.text or "").strip():
                      return norm(el.text)
              return ""

          def text_in(elem, wanted_set):
              wanted={x.lower() for x in wanted_set}
              for x in elem.iter():
                  if localname(x.tag).lower() in wanted and (x.text or "").strip():
                      return norm(x.text)
              return ""

          def retailer_from(chain_id, chain_name):
              if chain_id in CHAINID_TO_RETAILER: return CHAINID_TO_RETAILER[chain_id]
              cn=chain_name or ""
              if "שופרסל" in cn: return "shufersal"
              if "רמי" in cn: return "ramilevy"
              if "יוחננוף" in cn: return "yohananof"
              return None

          def score(city,address,name):
              hay=norm(f"{city or ''} {address or ''} {name or ''}")
              hay2=re.sub(r"[\s\-]","",hay)
              for tok in TARGET_TOKENS:
                  if tok in hay: return True
                  if re.sub(r"[\s\-]","",tok) in hay2: return True
              return False

          def city_from_shuf_name(name):
              n=norm(name)
              if not n: return ""
              parts=n.split(" ")
              if len(parts)>=2:
                  last2=" ".join(parts[-2:])
                  if re.search(r"[א-ת]", last2): return last2
              last1=parts[-1]
              if re.search(r"[א-ת]", last1): return last1
              return ""

          def parse_store_file(path):
              root=ET.parse(path).getroot()
              chain_id=find_first(root,"chainid")
              chain_name=find_first(root,"chainname")
              stores=[]
              for el in root.iter():
                  if localname(el.tag).lower()!="store": continue
                  store_id=text_in(el,{"storeid"})
                  if not store_id: continue
                  name=text_in(el,{"storename"}) or ""
                  address=text_in(el,{"address"}) or ""
                  if address.lower()=="unknown": address=""
                  city=text_in(el,{"city"}) or ""
                  if (not city) or city.lower()=="unknown" or looks_numeric(city): city=""
                  stores.append((store_id, city, address, name))
              return chain_id, chain_name, stores

          candidates={"ramilevy":[],"shufersal":[],"yohananof":[]}
          for path in glob.glob("dumps/**/*.xml", recursive=True):
              base=os.path.basename(path).lower()
              if not base.startswith("stores"): continue
              try:
                  chain_id, chain_name, stores=parse_store_file(path)
              except Exception:
                  continue
              retailer=retailer_from(chain_id, chain_name)
              if retailer in candidates and stores: candidates[retailer].extend(stores)

          if not any(candidates.values()):
              raise SystemExit("No parsable STORE records found.")

          def make_store_obj(retailer, store_id, city, address, name):
              obj={"retailer":retailer, "store_id":str(store_id), "store_key":f"{retailer}:{store_id}"}
              if name: obj["store_name"]=name
              if city: obj["city"]=city
              if address: obj["address"]=address
              return obj

          selected=[]; seen=set()
          def add_unique(obj):
              sk=obj["store_key"]
              if sk in seen: return
              seen.add(sk); selected.append(obj)

          def pick(retailer, limit):
              items=candidates.get(retailer, [])
              preferred=[]; fallback=[]
              for store_id, city, address, name in items:
                  if retailer=="shufersal" and (not city or looks_numeric(city) or city.lower()=="unknown"):
                      city=city_from_shuf_name(name)
                  (preferred if score(city,address,name) else fallback).append((store_id,city,address,name))
              out=preferred[:limit]
              if len(out)<limit: out.extend(fallback[:(limit-len(out))])
              return out

          per=15
          for store_id, city, address, name in pick("ramilevy", per):
              add_unique(make_store_obj("ramilevy", store_id, city, address, name))
          for store_id, city, address, name in pick("shufersal", per):
              add_unique(make_store_obj("shufersal", store_id, city, address, name))

          # fill up to 30
          combined=[]
          for retailer in ("ramilevy","shufersal"):
              for tup in candidates.get(retailer, []):
                  combined.append((retailer, *tup))
          for retailer, store_id, city, address, name in combined:
              if len(selected) >= LIMIT_RAMI_SHUF_TOTAL: break
              if retailer=="shufersal" and (not city or looks_numeric(city) or city.lower()=="unknown"):
                  city=city_from_shuf_name(name)
              add_unique(make_store_obj(retailer, store_id, city, address, name))

          # yohananof up to 15
          y_added=0
          for store_id, city, address, name in pick("yohananof", PER_RETAILER_YOH):
              if y_added >= PER_RETAILER_YOH: break
              before=len(selected)
              add_unique(make_store_obj("yohananof", store_id, city, address, name))
              if len(selected)>before: y_added += 1

          if not selected:
              raise SystemExit("No stores selected.")

          now=now_z()
          dummy_store_key=selected[0]["store_key"]

          payload={
              "source":"mvp_bootstrap_stores_3networks",
              "generated_at":now,
              "stores":selected,
              "records":[{
                  "price_key":f"{DUMMY_BARCODE}:{dummy_store_key}",
                  "barcode":DUMMY_BARCODE,
                  "store_key":dummy_store_key,
                  "price":DUMMY_PRICE,
                  "updated_at":now
              }]
          }

          os.makedirs("out", exist_ok=True)
          with open("out/payload.json","w",encoding="utf-8") as f:
              json.dump(payload,f,ensure_ascii=False)
          print("Wrote out/payload.json")
          PY

      # =========================
      # BUILD (seed_products / stores_prices): out/products_seed.csv + out/payload.json
      # =========================
      - name: Build products_seed.csv + payload.json (seed_products / stores_prices)
        if: ${{ inputs.run_mode == 'seed_products' || inputs.run_mode == 'stores_prices' }}
        env:
          SEED_LIMIT: ${{ inputs.seed_limit }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os, json, glob, re, gzip, zipfile
          import xml.etree.ElementTree as ET
          from datetime import datetime, timezone

          SEED_LIMIT=int(os.environ.get("SEED_LIMIT","2000"))
          MAX_STORES_TOTAL=30
          MAX_RECORDS_TOTAL=4000

          TARGET_TOKENS=["הוד השרון","כפר סבא","רעננה","הרצליה","רמת השרון","פתח תקווה","תל אביב","אחוזה"]
          CHAINID_TO_RETAILER={"7290027600007":"ramilevy","7290058140886":"shufersal"}

          def now_z():
              return datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00","Z")
          def norm(s): return re.sub(r"\s+"," ",(s or "").strip())
          def localname(tag): return tag.split("}")[-1] if "}" in tag else tag
          def looks_numeric(s): return bool(re.fullmatch(r"\d{1,18}", (s or "").strip()))

          def load_xml_roots(path):
              lp=path.lower()
              if lp.endswith(".zip"):
                  roots=[]
                  with zipfile.ZipFile(path,"r") as z:
                      for nm in z.namelist():
                          if nm.lower().endswith(".xml"):
                              roots.append(ET.fromstring(z.read(nm)))
                  return roots
              if lp.endswith(".xml.gz") or lp.endswith(".gz"):
                  with gzip.open(path,"rb") as f:
                      return [ET.fromstring(f.read())]
              return [ET.parse(path).getroot()]

          def iter_dump_paths():
              for p in glob.glob("dumps/**/*", recursive=True):
                  if os.path.isfile(p) and p.lower().endswith((".xml",".gz",".zip",".xml.gz")):
                      yield p

          def extract_any(elem, tagset):
              tagset={t.lower() for t in tagset}
              for el in elem.iter():
                  if localname(el.tag).lower() in tagset and (el.text or "").strip():
                      return norm(el.text)
              # fallback attributes
              for el in elem.iter():
                  for k,v in (el.attrib or {}).items():
                      kk=str(k).lower()
                      if any(t in kk for t in ["barcode","gtin","itemcode","ean","code"]):
                          vv=(v or "").strip()
                          if vv: return norm(vv)
              return ""

          def retailer_from(chain_id, chain_name):
              if chain_id in CHAINID_TO_RETAILER: return CHAINID_TO_RETAILER[chain_id]
              cn=chain_name or ""
              if "שופרסל" in cn: return "shufersal"
              if "רמי" in cn: return "ramilevy"
              if "יוחננוף" in cn or "YOHANANOF" in cn.upper(): return "yohananof"
              return None

          def score(city,address,name):
              hay=norm(f"{city or ''} {address or ''} {name or ''}")
              hay2=re.sub(r"[\s\-]","",hay)
              for tok in TARGET_TOKENS:
                  if tok in hay: return True
                  if re.sub(r"[\s\-]","",tok) in hay2: return True
              return False

          def city_from_shuf_name(name):
              n=norm(name)
              if not n: return ""
              parts=n.split(" ")
              if len(parts)>=2:
                  last2=" ".join(parts[-2:])
                  if re.search(r"[א-ת]", last2): return last2
              last1=parts[-1]
              if re.search(r"[א-ת]", last1): return last1
              return ""

          # --- pick up to 30 stores ---
          candidates={"ramilevy":[],"shufersal":[],"yohananof":[]}

          for path in iter_dump_paths():
              base=os.path.basename(path).lower()
              if not base.startswith("stores"): continue
              try:
                  for root in load_xml_roots(path):
                      chain_id=extract_any(root, {"chainid"})
                      chain_name=extract_any(root, {"chainname"})
                      retailer=retailer_from(chain_id, chain_name)
                      if retailer not in candidates: 
                          continue
                      for el in root.iter():
                          if localname(el.tag).lower()!="store": 
                              continue
                          store_id=extract_any(el, {"storeid"})
                          if not store_id: 
                              continue
                          name=extract_any(el, {"storename"}) or ""
                          address=extract_any(el, {"address"}) or ""
                          if address.lower()=="unknown": address=""
                          city=extract_any(el, {"city"}) or ""
                          if (not city) or city.lower()=="unknown" or looks_numeric(city): city=""
                          candidates[retailer].append((store_id, city, address, name))
              except Exception:
                  continue

          if not any(candidates.values()):
              raise SystemExit("No STORE records parsed (needed to build store_key).")

          def make_store_obj(retailer, store_id, city, address, name):
              obj={"retailer":retailer, "store_id":str(store_id), "store_key":f"{retailer}:{store_id}"}
              if name: obj["store_name"]=name
              if city: obj["city"]=city
              if address: obj["address"]=address
              return obj

          selected=[]; seen=set()
          def add_store(retailer, store_id, city, address, name):
              if retailer=="shufersal" and (not city or looks_numeric(city) or city.lower()=="unknown"):
                  city=city_from_shuf_name(name)
              obj=make_store_obj(retailer, store_id, city, address, name)
              sk=obj["store_key"]
              if sk in seen: return
              seen.add(sk); selected.append(obj)

          for retailer in ("ramilevy","shufersal","yohananof"):
              items=candidates.get(retailer, [])
              preferred=[]; fallback=[]
              for store_id, city, address, name in items:
                  (preferred if score(city,address,name) else fallback).append((store_id,city,address,name))
              for tup in preferred + fallback:
                  add_store(retailer, *tup)
                  if len(selected) >= MAX_STORES_TOTAL: break
              if len(selected) >= MAX_STORES_TOTAL: break

          store_keys=set(s["store_key"] for s in selected)

          # --- seed + records ---
          BARCODE_TAGS={"itemcode","barcode","gtin","ean","code","itemid","itemnumber"}
          NAME_TAGS={"itemname","itemdescription","productname","description","name"}
          PRICE_TAGS={"itemprice","price","unitprice","saleprice","priceafterdiscount","priceinclvat"}

          def safe_float(x):
              x=(x or "").strip().replace(",", ".")
              try:
                  v=float(x)
                  return v if v>=0 else None
              except Exception:
                  return None

          def iter_item_nodes(root):
              out=[]
              for el in root.iter():
                  if localname(el.tag).lower() in {"item","product"}:
                      out.append(el)
              return out

          seed_map={}
          dedup={}
          stats={"price_files_seen":0,"price_candidates_parsed":0,"items_scanned":0,"seed_unique":0,"records_built":0}

          for path in iter_dump_paths():
              base=os.path.basename(path).lower()
              if base.startswith("stores"): continue
              stats["price_files_seen"] += 1
              try:
                  roots=load_xml_roots(path)
              except Exception:
                  continue

              for root in roots:
                  chain_id=extract_any(root, {"chainid"})
                  chain_name=extract_any(root, {"chainname"})
                  store_id=extract_any(root, {"storeid"})
                  retailer=retailer_from(chain_id, chain_name)
                  if not retailer or not store_id:
                      continue

                  items=iter_item_nodes(root)
                  if not items:
                      continue

                  stats["price_candidates_parsed"] += 1
                  store_key=f"{retailer}:{store_id}"
                  updated_at=now_z()

                  for node in items:
                      stats["items_scanned"] += 1
                      bc=extract_any(node, BARCODE_TAGS).strip()
                      if not bc: 
                          continue

                      if bc not in seed_map and len(seed_map) < SEED_LIMIT:
                          nm=extract_any(node, NAME_TAGS).strip()
                          seed_map[bc]=nm
                          stats["seed_unique"]=len(seed_map)

                      if store_key not in store_keys:
                          continue
                      if bc not in seed_map:
                          continue

                      pv=safe_float(extract_any(node, PRICE_TAGS))
                      if pv is None:
                          continue

                      price_key=f"{bc}:{store_key}"
                      dedup[price_key]={
                          "price_key":price_key,
                          "barcode":bc,
                          "store_key":store_key,
                          "price":pv,
                          "updated_at":updated_at
                      }
                      if len(dedup) >= MAX_RECORDS_TOTAL:
                          break

                  if len(dedup) >= MAX_RECORDS_TOTAL:
                      break
              if len(dedup) >= MAX_RECORDS_TOTAL:
                  break

          records=list(dedup.values())
          stats["records_built"]=len(records)

          os.makedirs("out", exist_ok=True)

          with open("out/products_seed.csv","w",encoding="utf-8") as f:
              f.write("barcode,name\n")
              for bc, nm in seed_map.items():
                  f.write(f"{bc},{(nm or '').replace(',', ' ')}\n")

          payload={
              "source":"collector_seed_and_prices_3networks",
              "generated_at":now_z(),
              "stores":selected,
              "records":records
          }
          with open("out/payload.json","w",encoding="utf-8") as f:
              json.dump(payload,f,ensure_ascii=False)

          print("== STATS ==")
          for k,v in stats.items():
              print(f"{k}: {v}")
          print("Wrote out/products_seed.csv and out/payload.json")
          PY

      - name: Upload artifacts (out/)
        if: ${{ inputs.run_mode != 'inspect' }}
        uses: actions/upload-artifact@v4
        with:
          name: glutiwise-out
          path: out/

      # =========================
      # POST TO MAKE (only if requested)
      # =========================
      - name: POST out/payload.json to Make (ONE POST)
        if: ${{ (inputs.run_mode == 'stores' || inputs.run_mode == 'stores_prices') && inputs.send_to_make == 'true' }}
        env:
          MAKE_WEBHOOK_URL: ${{ secrets.MAKE_WEBHOOK_URL }}
          MAKE_APIKEY: ${{ secrets.MAKE_APIKEY }}
        run: |
          set -euo pipefail
          test -f out/payload.json
          curl -sS -X POST "$MAKE_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "x-make-apikey: $MAKE_APIKEY" \
            --data-binary @out/payload.json
